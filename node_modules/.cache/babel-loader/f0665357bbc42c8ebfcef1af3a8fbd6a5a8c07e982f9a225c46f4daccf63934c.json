{"ast":null,"code":"import { getGameSettings } from \"../constants\";\nimport { CellValue, CellState } from \"../types\";\nconst grabAllAdjacentCells = (cells, rowParam, colParam, value) => {\n  let settings = getGameSettings(value);\n  const MAX_ROWS = settings.MAX_ROWS;\n  const MAX_COLS = settings.MAX_COLS;\n  const topLeftCell = rowParam > 0 && colParam > 0 ? cells[rowParam - 1][colParam - 1] : null;\n  const topCell = rowParam > 0 ? cells[rowParam - 1][colParam] : null;\n  const topRightCell = rowParam > 0 && colParam < MAX_COLS - 1 ? cells[rowParam - 1][colParam + 1] : null;\n  const leftCell = colParam > 0 ? cells[rowParam][colParam - 1] : null;\n  const rightCell = colParam < MAX_COLS - 1 ? cells[rowParam][colParam + 1] : null;\n  const bottomLeftCell = rowParam < MAX_ROWS - 1 && colParam > 0 ? cells[rowParam + 1][colParam - 1] : null;\n  const bottomCell = rowParam < MAX_ROWS - 1 ? cells[rowParam + 1][colParam] : null;\n  const bottomRightCell = rowParam < MAX_ROWS - 1 && colParam < MAX_COLS - 1 ? cells[rowParam + 1][colParam + 1] : null;\n  return {\n    topLeftCell,\n    topCell,\n    topRightCell,\n    leftCell,\n    rightCell,\n    bottomLeftCell,\n    bottomCell,\n    bottomRightCell\n  };\n};\nexport const generateCells = value => {\n  let cells = [];\n  let settings = getGameSettings(value);\n  const MAX_ROWS = settings.MAX_ROWS;\n  const MAX_COLS = settings.MAX_COLS;\n  const NUM_OF_BOMBS = settings.NUM_OF_BOMBS;\n\n  // Generate all cells\n  for (let row = 0; row < MAX_ROWS; ++row) {\n    cells.push([]);\n    for (let col = 0; col < MAX_COLS; ++col) {\n      cells[row].push({\n        value: CellValue.none,\n        state: CellState.open\n      });\n    }\n  }\n\n  // Randomly put 10 bombs\n  let bombsPlaced = 0;\n  while (bombsPlaced < NUM_OF_BOMBS) {\n    const randomRow = Math.floor(Math.random() * MAX_ROWS);\n    const randomCol = Math.floor(Math.random() * MAX_COLS);\n    const currentCell = cells[randomRow][randomCol];\n    if (currentCell.value !== CellValue.bomb) {\n      cells = cells.map((row, rowIndex) => row.map((cell, colIndex) => {\n        if (randomRow === rowIndex && randomCol === colIndex) {\n          return {\n            ...cell,\n            value: CellValue.bomb\n          };\n        }\n        return cell;\n      }));\n      bombsPlaced++;\n    }\n  }\n\n  // Calculate the numbers for each cell\n  for (let rowIndex = 0; rowIndex < MAX_ROWS; ++rowIndex) {\n    for (let colIndex = 0; colIndex < MAX_COLS; ++colIndex) {\n      const currentCell = cells[rowIndex][colIndex];\n      if (currentCell.value === CellValue.bomb) {\n        continue;\n      }\n      let numberOfBombs = 0;\n      const {\n        topLeftCell,\n        topCell,\n        topRightCell,\n        leftCell,\n        rightCell,\n        bottomLeftCell,\n        bottomCell,\n        bottomRightCell\n      } = grabAllAdjacentCells(cells, rowIndex, colIndex, value);\n      if ((topLeftCell === null || topLeftCell === void 0 ? void 0 : topLeftCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if ((topCell === null || topCell === void 0 ? void 0 : topCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if ((topRightCell === null || topRightCell === void 0 ? void 0 : topRightCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if ((leftCell === null || leftCell === void 0 ? void 0 : leftCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if ((rightCell === null || rightCell === void 0 ? void 0 : rightCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if ((bottomLeftCell === null || bottomLeftCell === void 0 ? void 0 : bottomLeftCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if ((bottomCell === null || bottomCell === void 0 ? void 0 : bottomCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if ((bottomRightCell === null || bottomRightCell === void 0 ? void 0 : bottomRightCell.value) === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (numberOfBombs > 0) {\n        cells[rowIndex][colIndex] = {\n          ...currentCell,\n          value: numberOfBombs\n        };\n      }\n    }\n  }\n  return cells;\n};\nexport const openMultipleCells = (cells, rowParam, colParam, value) => {\n  let newCells = cells.slice();\n  newCells[rowParam][colParam].state = CellState.visible;\n  const {\n    topLeftCell,\n    topCell,\n    topRightCell,\n    leftCell,\n    rightCell,\n    bottomLeftCell,\n    bottomCell,\n    bottomRightCell\n  } = grabAllAdjacentCells(cells, rowParam, colParam, value);\n  if ((topLeftCell === null || topLeftCell === void 0 ? void 0 : topLeftCell.state) === CellState.open && topLeftCell.value !== CellValue.bomb) {\n    if (topLeftCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam - 1, colParam - 1, value);\n    } else {\n      newCells[rowParam - 1][colParam - 1].state = CellState.visible;\n    }\n  }\n  if ((topCell === null || topCell === void 0 ? void 0 : topCell.state) === CellState.open && topCell.value !== CellValue.bomb) {\n    if (topCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam - 1, colParam, value);\n    } else {\n      newCells[rowParam - 1][colParam].state = CellState.visible;\n    }\n  }\n  if ((topRightCell === null || topRightCell === void 0 ? void 0 : topRightCell.state) === CellState.open && topRightCell.value !== CellValue.bomb) {\n    if (topRightCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam - 1, colParam + 1, value);\n    } else {\n      newCells[rowParam - 1][colParam + 1].state = CellState.visible;\n    }\n  }\n  if ((leftCell === null || leftCell === void 0 ? void 0 : leftCell.state) === CellState.open && leftCell.value !== CellValue.bomb) {\n    if (leftCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam, colParam - 1, value);\n    } else {\n      newCells[rowParam][colParam - 1].state = CellState.visible;\n    }\n  }\n  if ((rightCell === null || rightCell === void 0 ? void 0 : rightCell.state) === CellState.open && rightCell.value !== CellValue.bomb) {\n    if (rightCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam, colParam + 1, value);\n    } else {\n      newCells[rowParam][colParam + 1].state = CellState.visible;\n    }\n  }\n  if ((bottomLeftCell === null || bottomLeftCell === void 0 ? void 0 : bottomLeftCell.state) === CellState.open && bottomLeftCell.value !== CellValue.bomb) {\n    if (bottomLeftCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam + 1, colParam - 1, value);\n    } else {\n      newCells[rowParam + 1][colParam - 1].state = CellState.visible;\n    }\n  }\n  if ((bottomCell === null || bottomCell === void 0 ? void 0 : bottomCell.state) === CellState.open && bottomCell.value !== CellValue.bomb) {\n    if (bottomCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam + 1, colParam, value);\n    } else {\n      newCells[rowParam + 1][colParam].state = CellState.visible;\n    }\n  }\n  if ((bottomRightCell === null || bottomRightCell === void 0 ? void 0 : bottomRightCell.state) === CellState.open && bottomRightCell.value !== CellValue.bomb) {\n    if (bottomRightCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam + 1, colParam + 1, value);\n    } else {\n      newCells[rowParam + 1][colParam + 1].state = CellState.visible;\n    }\n  }\n  return newCells;\n};","map":{"version":3,"names":["getGameSettings","CellValue","CellState","grabAllAdjacentCells","cells","rowParam","colParam","value","settings","MAX_ROWS","MAX_COLS","topLeftCell","topCell","topRightCell","leftCell","rightCell","bottomLeftCell","bottomCell","bottomRightCell","generateCells","NUM_OF_BOMBS","row","push","col","none","state","open","bombsPlaced","randomRow","Math","floor","random","randomCol","currentCell","bomb","map","rowIndex","cell","colIndex","numberOfBombs","openMultipleCells","newCells","slice","visible"],"sources":["/Users/lijiheng/CS/GithubProject/minesweeper/src/utils/index.ts"],"sourcesContent":["import { getGameSettings } from \"../constants\";\nimport { Cell, CellValue, CellState } from \"../types\";\n\nconst grabAllAdjacentCells = (\n  cells: Cell[][],\n  rowParam: number,\n  colParam: number,\n  value: string\n): {\n  topLeftCell: Cell | null;\n  topCell: Cell | null;\n  topRightCell: Cell | null;\n  leftCell: Cell | null;\n  rightCell: Cell | null;\n  bottomLeftCell: Cell | null;\n  bottomCell: Cell | null;\n  bottomRightCell: Cell | null;\n} => {\n  let settings = getGameSettings(value);\n  const MAX_ROWS = settings.MAX_ROWS;\n  const MAX_COLS = settings.MAX_COLS;\n\n  const topLeftCell =\n    rowParam > 0 && colParam > 0 ? cells[rowParam - 1][colParam - 1] : null;\n  const topCell = rowParam > 0 ? cells[rowParam - 1][colParam] : null;\n  const topRightCell =\n    rowParam > 0 && colParam < MAX_COLS - 1\n      ? cells[rowParam - 1][colParam + 1]\n      : null;\n  const leftCell = colParam > 0 ? cells[rowParam][colParam - 1] : null;\n  const rightCell =\n    colParam < MAX_COLS - 1 ? cells[rowParam][colParam + 1] : null;\n  const bottomLeftCell =\n    rowParam < MAX_ROWS - 1 && colParam > 0\n      ? cells[rowParam + 1][colParam - 1]\n      : null;\n  const bottomCell =\n    rowParam < MAX_ROWS - 1 ? cells[rowParam + 1][colParam] : null;\n  const bottomRightCell =\n    rowParam < MAX_ROWS - 1 && colParam < MAX_COLS - 1\n      ? cells[rowParam + 1][colParam + 1]\n      : null;\n\n  return {\n    topLeftCell,\n    topCell,\n    topRightCell,\n    leftCell,\n    rightCell,\n    bottomLeftCell,\n    bottomCell,\n    bottomRightCell,\n  };\n};\n\nexport const generateCells = (value: string): Cell[][] => {\n  let cells: Cell[][] = [];\n  let settings = getGameSettings(value);\n  const MAX_ROWS = settings.MAX_ROWS;\n  const MAX_COLS = settings.MAX_COLS;\n  const NUM_OF_BOMBS = settings.NUM_OF_BOMBS;\n\n  // Generate all cells\n  for (let row = 0; row < MAX_ROWS; ++row) {\n    cells.push([]);\n    for (let col = 0; col < MAX_COLS; ++col) {\n      cells[row].push({\n        value: CellValue.none,\n        state: CellState.open,\n      });\n    }\n  }\n\n  // Randomly put 10 bombs\n  let bombsPlaced = 0;\n  while (bombsPlaced < NUM_OF_BOMBS) {\n    const randomRow = Math.floor(Math.random() * MAX_ROWS);\n    const randomCol = Math.floor(Math.random() * MAX_COLS);\n\n    const currentCell = cells[randomRow][randomCol];\n    if (currentCell.value !== CellValue.bomb) {\n      cells = cells.map((row, rowIndex) =>\n        row.map((cell, colIndex) => {\n          if (randomRow === rowIndex && randomCol === colIndex) {\n            return {\n              ...cell,\n              value: CellValue.bomb,\n            };\n          }\n\n          return cell;\n        })\n      );\n      bombsPlaced++;\n    }\n  }\n\n  // Calculate the numbers for each cell\n  for (let rowIndex = 0; rowIndex < MAX_ROWS; ++rowIndex) {\n    for (let colIndex = 0; colIndex < MAX_COLS; ++colIndex) {\n      const currentCell = cells[rowIndex][colIndex];\n      if (currentCell.value === CellValue.bomb) {\n        continue;\n      }\n\n      let numberOfBombs = 0;\n      const {\n        topLeftCell,\n        topCell,\n        topRightCell,\n        leftCell,\n        rightCell,\n        bottomLeftCell,\n        bottomCell,\n        bottomRightCell,\n      } = grabAllAdjacentCells(cells, rowIndex, colIndex, value);\n\n      if (topLeftCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (topCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (topRightCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (leftCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (rightCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (bottomLeftCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (bottomCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n      if (bottomRightCell?.value === CellValue.bomb) {\n        numberOfBombs++;\n      }\n\n      if (numberOfBombs > 0) {\n        cells[rowIndex][colIndex] = {\n          ...currentCell,\n          value: numberOfBombs,\n        };\n      }\n    }\n  }\n\n  return cells;\n};\n\nexport const openMultipleCells = (\n  cells: Cell[][],\n  rowParam: number,\n  colParam: number,\n  value: string\n): Cell[][] => {\n  let newCells = cells.slice();\n\n  newCells[rowParam][colParam].state = CellState.visible;\n\n  const {\n    topLeftCell,\n    topCell,\n    topRightCell,\n    leftCell,\n    rightCell,\n    bottomLeftCell,\n    bottomCell,\n    bottomRightCell,\n  } = grabAllAdjacentCells(cells, rowParam, colParam, value);\n\n  if (\n    topLeftCell?.state === CellState.open &&\n    topLeftCell.value !== CellValue.bomb\n  ) {\n    if (topLeftCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam - 1, colParam - 1, value);\n    } else {\n      newCells[rowParam - 1][colParam - 1].state = CellState.visible;\n    }\n  }\n\n  if (topCell?.state === CellState.open && topCell.value !== CellValue.bomb) {\n    if (topCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam - 1, colParam, value);\n    } else {\n      newCells[rowParam - 1][colParam].state = CellState.visible;\n    }\n  }\n\n  if (\n    topRightCell?.state === CellState.open &&\n    topRightCell.value !== CellValue.bomb\n  ) {\n    if (topRightCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam - 1, colParam + 1, value);\n    } else {\n      newCells[rowParam - 1][colParam + 1].state = CellState.visible;\n    }\n  }\n\n  if (leftCell?.state === CellState.open && leftCell.value !== CellValue.bomb) {\n    if (leftCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam, colParam - 1, value);\n    } else {\n      newCells[rowParam][colParam - 1].state = CellState.visible;\n    }\n  }\n\n  if (\n    rightCell?.state === CellState.open &&\n    rightCell.value !== CellValue.bomb\n  ) {\n    if (rightCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam, colParam + 1, value);\n    } else {\n      newCells[rowParam][colParam + 1].state = CellState.visible;\n    }\n  }\n\n  if (\n    bottomLeftCell?.state === CellState.open &&\n    bottomLeftCell.value !== CellValue.bomb\n  ) {\n    if (bottomLeftCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam + 1, colParam - 1, value);\n    } else {\n      newCells[rowParam + 1][colParam - 1].state = CellState.visible;\n    }\n  }\n\n  if (\n    bottomCell?.state === CellState.open &&\n    bottomCell.value !== CellValue.bomb\n  ) {\n    if (bottomCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam + 1, colParam, value);\n    } else {\n      newCells[rowParam + 1][colParam].state = CellState.visible;\n    }\n  }\n\n  if (\n    bottomRightCell?.state === CellState.open &&\n    bottomRightCell.value !== CellValue.bomb\n  ) {\n    if (bottomRightCell.value === CellValue.none) {\n      newCells = openMultipleCells(newCells, rowParam + 1, colParam + 1, value);\n    } else {\n      newCells[rowParam + 1][colParam + 1].state = CellState.visible;\n    }\n  }\n\n  return newCells;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}